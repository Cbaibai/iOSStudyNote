Swift简介(一)
===

虽然目前国内大部分应用还都是用OC开发，但是Swift毕竟是亲儿子。

正如Android除了Kotlin一样，未来Kotlin会是主流。所以我还是更喜欢学Swift.

从前面接触OC的学习，感觉作为一个从Java转过来的开发者，实在接受不了OC的语法，所以还是下定决心学Swift，毕竟Swift和Kotlin还是
有些类似的。  

Swift是一款全新的面向IOS和OS Apps的编程语言，建立在C语言和Objective-C语言的基础之上，而且，完美兼容C语言。Swift采用了安全编程模式，增加了许多现代语言的新特性，让编程工作变得更加简易，灵活和有趣。Swift在成熟而且广受欢迎Cocoa 和 Cocoa Touch框架上重新开始，为软件开发工作提供了新视野。


HelloWorld
---

```swift
print("Hello World")
```

一行代码的HelloWorld见过吗？ Swift就是，不用导包，不用main函数，全局作用域中的代码会被自动当做程序的入口，同样也不需要在每个语句后面加分号。爽爽爽!

使用swift新建一个ios工程，可以看到Swift将OC中的h和m文件合并成了一个文件。
<img src="https://github.com/CharonChui/Pictures/blob/master/swfit_demo.png" width="100%" height="100%"/>


Swift语言并不是像C/C++，Java那样完全忽视空格，Swift对空格的使用有一定的要求，但是又不像Python对缩进的要求那么严格。

在Swift中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错:  
```swift
let a= 1 + 2

let a= 1 + 2
```
正确的写法是:    
```swift
let a = 1 + 2
```

变量
---

变量定义:   

使用var关键字
```swift
var string = "hello world"
var a = 42
var var:Float
var = 3.14159
print(string)
```

常量
---


let 用于定义常量，定义完后不能修改。
var 用于定义变量，可以修改。

```swift
let constA = 42
let constB:Float = 3.14159
```

可选类型
---

Swift的可选(Optional)类型，用于处理值缺失的情况。可选表示"那里有一个值，并且它等于x或者那里没有值"。

Swift语言定义后缀?作为命名类型Optional的缩写，换句话说，以下两种声明是相等的:   
```swift
var optionalInteger: Int?  // 注意类型和？之间没有空格
var optionalInteger: Optional<Int>
```
Optional 是一个含有两种情况的枚举，None和Some(T)，用来表示可能有或可能没有值。任何类型都可以明确声明为（或者隐式转换）可选类型。当声明一个可选类型的时候，要确保用括号给？操作符一个合适的范围。例如，声明可选整数数组，应该写成(Int[])?；写成Int[]?会报错。

当你声明一个可选变量或者可选属性的时候没有提供初始值，它的值会默认为nil。

可选项遵照LogicValue协议，因此可以出现在布尔环境中。在这种情况下，如果可选类型T?包含类型为T的任何值（也就是说它的值是Optional.Some(T)），这个可选类型等于true，反之为false。

如果一个可选类型的实例包含一个值，你可以用后缀操作符 ！来访问这个值，如下所示：
```swift
optionalInteger = 42
optionalInteger! // 42
```
强制解析
---

包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个感叹号表示"我知道这个可选有值，请使用它。"这被称为可选值的强制解析（forced unwrapping）。

实例如下：
```swift
var myString:String?

myString = "Hello, Swift!"

if (myString != nil) {
    print(myString)
}else{
    print("myString 值为 nil")
}
```
执行结果为:   
```
"Optional("Hello, Swift!")\n"
```
强制解析可选值，使用感叹号（!):
```swift
myString = "Hello, Swift!"

if (myString != nil) {
    print(myString!)
}else{
    print("myString 值为 nil")
}
```
执行结果:   
```
"Hello, Swift!"
```


自动解析
---

你可以在声明可选变量时使用感叹号(!)替换问好(?)，这样可选变量在使用时就不需要再加一个感叹号(!)来获取值，它会自动解析。
```swift
var myString:String!
myString = "Hello World!"
if (myString != nil) {
	print(myString)
} else {
	print("nil")
}
```
执行结果:   
```swift
Hello World!
```



输出
---

变量和常量可以使用print函数来输出。在字符串中可以使用括号与反斜线来插入变量:   

```swift
var name = "hello"
var age = 20
print("\(name)的年龄是\(site)")
```



数据类型
---


- Int 
- UInt
- Float
- Double
- Bool
- String "Hello World!"
- Character "c"// 注意和Java中不一样


类型别名
---

```swift
typealias newName = type
```

字符串
---

使用==来比较两个字符串是否相等。

Swift中的string类型是值类型。如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数方法中床底时，都会进行值拷贝。


import Cocoa

for ch in "Runoob".characters {
    print(ch)
}

运算符条件语句神马的都和java一样。而且还支持三元运算符。


数组
---


```swift
var arr = [type]()
// 初始化一个number数量的数组，初始化值为initialValue
var arr = [type](repeating: initialValue, count: number)
var arr:[Int] = [1, 2, 3, 4, 5]
// 访问数组元素
var value = arr[0]
```

添加数组元素:   
```swift
var arr = [Int]()
// 使用append或+=来添加数组
arr.append(1)
arr.append(2)
arr += [3]

for item in arr {
	print(item)
}
// 使用enumerate()来获取每个数据项的值和索引值
for (index, item) in arr.enumerated() {
    print("在 index = \(index) 位置上的值为 \(item)")
}

使用+来合并两个数组
var arr3 = arr1 + arr2
```

字典
---

```swift
var map = [keyType:ValueType]()
var map = [Int:String]()
var map = [1:"One", 2:"Two", 3:"Three"]
var value = map[2]
var oldValue = map.updateValue("2", forKey:2)
var removeValue = map.removeValue(forKey:2)
for (key, value) in map.enumerated() {
    print("key \(key) ..value \(value)")
}
// 字典转数组
var arr = [Int](map.keys)
var valueArr = [String](map.values)

var count = map.count
Bool isEmpty = map.isEmpty()
```


集合
---

Set集合用于存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。 


```swift
var letters = Set<Character>()
letters.insert("a")

// 将letters变成空set，但是它仍然是Set<Character>类型
letters = []
```

```swift
var set: Set<String> = ["a", "b", "c"]
```


函数
---

```swift
func name(param) -> returnType {

}

func sayHello(site: String) -> String {
    return site + " world"
}
print(sayHello(site: "hello"))

// 一般默认在函数中定义的参数都是常量参数，也就是说这个参数只可以查询，不能修改，如果在参数定义前加inout关键字，这样就可以
改变这个参数的值了。 
func getName(name: inout String) ....
```

枚举
---

```swift
enum DayofWeek {
	case Monday
	case Tuesday
	case Wednesday
	case Thursday
	case Friday
	case Saturday
	case Sunday
}

var day = DayofWeek.Monday
```

结构体
---

```swift
struct Person {
	var name: String
	var age: Int
	// 默认的构造初始化方法，如果有初始化值的需求，可以使用init方法
	init(name: String, age: Int) {
		self.name = name
		self.age = age
	}
}

var person = Person(name: "haha", age: 20)
print(person.name)
```

上面的init方法其实就是Swift中的构造方法:  




类
---

```swift
class Person {
	// 类中的属性必须要初始化
    var name: String = "haha"
    var age: Int = 20
    // 静态属性、方法，习惯了和Java中的叫法，叫静态...
    static var Tag = "n"
}

var person = Person()
person.age = 18
print(person.age)
```
写到这里有点懵逼了，类和结构体有什么区别呢？因为他们有很多共同的地方，区别就在于:   
- 继承允许一个类继承另一个类的特征
- 类型转换允许在运行时检查和解释一个类实例的类型
- 结构器允许一个类实例释放任何其他所被分配的资源
- 引用计数允许对一个类的多次引用

因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例。     
为了能够判定两个常量或者变量是否引用同一个类实例，Swift内使用恒等运算符: === 和 !==


类型的每一个实例都有一个隐含属性叫做self，self 完全等同于该实例本身。     
你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。其实就是Java中的this。


类型方法
---

就是Java中的静态方法，在结构体和枚举类型中可以在方法的func关键字之前加上static，类中可以使用class关键字来允许子类重写父类的方法:   
```swift
class Math {
    class func abs(number: Int) -> Int {
        if number < 0 {
            return (-number)
        } else {
            return number
        }
    }
}

struct absno {
    static func abs(number: Int) -> Int {
        if number < 0 {
            return (-number)
        } else {
            return number
        }
    }
}

let no = Math.abs(number: -35)
let num = absno.abs(number: -5)

print(no)
print(num)

```

继承
---

```swift
class SubClass: SuperClass  {
	// 重写
    override func show() {
        print("这是子类 SubClass")
    }
}
```

swift中属性和方法都可以重写，可以使用final关键字来声明不允许重写。

延迟加载
---

和Kotlin类似。  
```swift
lazy var no = number()
```


扩展
---


扩展就是向一个已有的类、结构体或枚举类型添加新功能。扩展可以对一个类型添加新的功能，但是不能重写已有的功能。
这一点和Kotlin中的扩展很类似。

```swift
extension SomeType {
	....
}
```

协议
---

协议规定了用来实现某一特定功能所必须的方法和属性，任何能够满足协议要求的类型被称为遵循这个协议。 可以简单的理解成Java中的接口。    
```swift
// 声明协议
protocol XXX {
    init(a: Int)
}
// 遵循某个协议
struct SomeStruct: FirstProtocal, AnotherProtocol {
    required init(a: Int) {
        // ....
    }
}
class SomeClass: SomeSuperClass, FirstProtocal, AnotherProtocal {
    required init(a: Int) {
        // ...
    }
}
```
你可以在遵循该协议的类中实现构造器，并指定其为类的指定构造器或者便利构造器。在这两种情况下，你都必须给构造器实现标上"required"修饰符。 


协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的内容要求。

协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔:    
```swift
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 协议定义
}
```

访问级别
---

Swift为代码中的实体提供了四种不同的访问级别:public internal fileprivate private

错误处理
---


```swift
func canThrowAnError() throws {

}

do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
} catch {
    print(error)
}
```
在 do 代码块中，使用 try 来标记可以抛出错误的代码。在 catch 代码块中，除非你另外命名，否则错误会自动命名为 error 。


元祖
---


元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。

下面这个例子中，(404, "Not Found") 是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 404 Not Found 状态码。
```swift
// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")
let http404Error = (404, "Not Found")

let (statusCode, statusMessage) = http404Error
// 输出 "The status code is 404"
print("The status code is \(statusCode)")
// 输出 "The status message is Not Found"
print("The status message is \(statusMessage)")
```

排序
---

Swift标准库提供了名为sorted(by:)的方法，它会根据你所提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，sorted(by:)方法会返回一个与原数组大小相同，包含同类型元素并且元素已正确排序的新数组。原数组不会被sorted(by:)方法修改。  

```swift
let names = ["a", "b", "c"]
func backward(s1: String, s2: String) -> Bool {
    return s1 > s2
}
let sortedNames = names.sorted(by: backward)

for name in sortedNames {
    print(name)
}
```



- [下一篇:Golang new和make的区别(十三)](https://github.com/CharonChui/GolangStudyNote/blob/master/13.Golang%20new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB(%E5%8D%81%E4%B8%89).md)


---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
